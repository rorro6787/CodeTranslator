# 3-Directions Code Translator
This is the final project I completed in the Language Processors course during my third year of Computer Engineering. This assignment involves the implementation, using JFlex and Cup, of a compiler for a small programming language similar to C, called the PLX language. PLX is an extension of the PL language, which is described as part of the course practice, but this extended version requires some additional functions. It is assumed that all elements of the PL language are present in the PLX language and that their functionality is not altered by the inclusion of the new elements in this extension. The main difference between PL and PLX is that PLX requires prior declaration of variables. The intermediate code generated by both languages is the same, as is the compilation scheme. The following image represents a flowchart that describes the process of compiling and executing a program.

<p align="center">
   <br>
   <img src="https://github.com/rorro6787/rorro6787/blob/main/Images/plxc.png" width = 100%/>
</p>

## Compiler Description

- **Lexical Aspects**: from a lexical perspective, the PLX language is similar to C, C++, and Java, and follows the same rules for variable declaration scope. PLX accepts the same type of comments as C++. Any ambiguity arising during implementation, not sufficiently clarified in this statement, should be resolved according to the specifications of these languages.
  
- **Types**: the PLX language has four basic types corresponding to Java types: int, float, boolean, and char. Each of these types has associated constants; integers use decimal notation, floats use decimal point and exponent notation, and characters appear in single quotes. The composite type String is also used, with constants being character sequences in double quotes, just like in Java. One-dimensional arrays of any of the aforementioned simple types can be defined, with character arrays being equivalent to the String type.
- **Variable Declaration**: variables must be declared by assigning them a type before they can be used. Variable identifiers consist of alphanumeric characters, starting with a non-numeric character, similar to Java. Multiple variables can be declared on the same line, separated by commas, and can optionally be assigned an initial value. If a variable is not initialized, it is considered to have a value of zero (or the equivalent according to its type).
- **Arithmetic Expressions**: the language includes arithmetic expressions with the four operators: addition, subtraction, multiplication, and division. The operation translated at the intermediate code level depends on the type of the expression, with both integers and real numbers interoperating, performing implicit or explicit conversions between integers and reals if necessary. The addition operation applied to two characters implies their concatenation (as in Java), resulting in a String object.
- **Conditions**: conditions result from applying relational operators (equal, not equal, less than, greater than, less than or equal to, etc.) between two expressions. Conditions can be composed using the logical operators of conjunction, disjunction, and negation (&&, ||, and !) with short-circuit evaluation.
- **Output Statement**: the only output statement is the print instruction, which can be applied to any of the PLX language types. The generated code will vary depending on the type.
- **Control Statements**: the core of the language will include assignment statements and the control statements if-else, while, do-while, and for, with the same semantics as in the Java language. Control statements can be nested within each other.
- **Error Detection**: the compiler does not incorporate fault recovery, so it stops execution upon encountering the first incorrect instruction, whether in lexical, syntactic, or semantic analysis. In such cases, the output only needs to contain the instruction “error”, without needing to indicate the cause.

## 3-Directions Code

The CTD object code implements an abstract machine with infinite registers accessed through variables. All variables are considered to be predefined, and their initial value is 0. There is no distinction between integers and real numbers, except when performing operations. The set of instructions for the intermediate code and their semantics are as follows:
<p align="center">
   <br>
   <img src="https://github.com/rorro6787/rorro6787/blob/main/Images/codigo%C3%A7.png" width = 100%/>
</p>

## Usability
First of all, it is necessary to set up the "CUP" and "JFLEX" environment. To do this, follow the same steps as described on this WEB page: https://www2.in.tum.de/repos/cup/develop/testgrammars/calc/ and perform the following actions:
1. To compile CUP, JFLEX, and the JAVA files, use the following instructions (each person should adapt them to the paths on their own computer):
   
   ```bash
   java -jar /Applications/cup-0.11b/java-cup-11b.jar Calculadora.cup /Applications/jflex-1.8.2/bin/jflex Calculadora.flex
   javac -cp /Applications/cup-0.11b/java-cup-11b-runtime.jar:. *.java
   java -cp /Applications/cup-0.11b/java-cup-11b-runtime.jar:. Calculadora test1.txt 
2. For greater convenience, it is advisable to locally define the CLASSPATH environment variable in the shell startup file, for example in the file "$HOME/.profile" (depending on the shell each person uses), and to create a "cup" file in a location accessible in the PATH. For instance, create the file "/usr/local/bin/cup" with the following content:
   
   ```bash
   export CLASSPATH=.:/Applications/cup-0.11b/java-cup-11b-runtime.jar
   java -jar /Applications/cup-0.11b/java-cup-11b.jar $@

3. Once the previous step is configured, the following sequence should work directly:
   
   ```bash
   cup Calculadora.cup
   jflex Calculadora.flex 
   javac *.java
   java Calculadora test1.txt
3. You can also use the macro included in the source code to perform all the above instructions at once:
   
   ```bash
   . comp.sh

4. In the src directory of the repository, you can also find the ctd file that compiles the three-address code and returns the compilation result:
   
   ```bash
   java PLXC test1.plx tes1.ctd 
   ./ctd test1.ctd
